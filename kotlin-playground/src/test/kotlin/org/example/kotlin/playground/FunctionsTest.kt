package org.example.kotlin.playground

import org.junit.jupiter.api.Test


class FunctionsTest {

  private infix fun String.infix_concat_print(value: String) {
    println(this + value)
  }

  @Test
  fun infix_test() {
    "Left ".infix_concat_print("Right")
    "Left " infix_concat_print "Right"
  }

  @Test
  fun func_names() {
    fun `function with spaces`() {
      println("test")
    }
    `function with spaces`()
  }

  @Test
  fun trailing_lambda_aka_lambda_last_parameter() {
    /*Passing a lambda to the last parameter
In Kotlin, there is a convention: if the last parameter of a function is a function, then a lambda expression passed as the corresponding argument can be placed outside the parentheses:
val product = items.fold(1) { acc, e -> acc * e }
Such syntax is also known as trailing lambda.
     */
    fun run(msg: String, body: () -> Unit) {
      println("$msg[S]")
      body()
      println("$msg[E]")
    }

    run("trailing_lambda_run") {
      println("trailing_lambda")
    }
  }

  @Test
  fun it_implicit_name_single_param() {
    fun run(body: (param: String) -> Unit) {
      body("single_param")
    }

    run {
      println(it)
    }
  }

  @Test
  fun `Returning a value from a lambda expression`() {
    val ints = listOf(1, -2, 3, -4, 5)

    // these exprs are equivalent

    println(ints.filter {
      val shouldFilter = it > 0
      shouldFilter
    })

    println(ints.filter {
      val shouldFilter = it > 0
      return@filter shouldFilter
    })
  }

  @Test
  fun closure() {
    val ints = listOf(1, -2, 3, -4, 5)
    var sum = 0
    ints.filter { it > 0 }.forEach {
      // can access non final variable in closure/func
      sum += it
    }
    print(sum)
  }

  @Test
  fun inline_func() {
    /*
    Using higher-order functions imposes certain runtime penalties: each function is an object, and it captures a closure,
    i.e. those variables that are accessed in the body of the function. Memory allocations (both for function objects and classes)
    and virtual calls introduce runtime overhead.
    But it appears that in many cases this kind of overhead can be eliminated by inlining the lambda expressions.
    The functions shown below are good examples of this situation.
    I.e., the lock() function could be easily inlined at call-sites. Consider the following case.

Usage:
So here are some suggested rules:

You can inline when functional type param is called directly or passed to other inline function
You should inline when ^ is the case.
You cannot inline when function parameter is being assigned to variable inside function
You should consider inlining if at least one of your functional typed parameters can be inlined, use noinline for the rest.
You should not inline huge functions, think about generated byte code. It will be copied to all places the function is called from.
Another use case is reified type parameters, which require you to use inline
     */

    var l = Locker()
    sync_run_lambda_inline(l) {
      println(l)
    }
  }

  @Test
  fun reified_test() {
    println(membersOf<String>())
    println(membersOf<FunctionsTest>())
  }

  inline fun <reified T> membersOf() = T::class.members

  class Locker {

    fun lock() = println("lock")
    fun unlock() = println("unlock")
  }

  inline fun <T> sync_run_lambda_inline(l: Locker, body: () -> T): T {
    l.lock()
    try {
      return body()
    } finally {
      l.unlock()
    }
  }

}